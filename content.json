{"meta":{"title":"木水の博客","subtitle":"木水の博客","description":"本科 | 河南科技大学 | 软件工程 ","author":"木水","url":"https://admin-zlj.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2022-03-29T04:58:56.000Z","updated":"2022-03-30T09:53:14.443Z","comments":false,"path":"about/index.html","permalink":"https://admin-zlj.github.io/about/index.html","excerpt":"","text":"About me 张xx，在校生，就读于河南科技大学软件工程系~~~ 立志成为前端大神的小白~~~ 座右铭：人生之败，非懒即惰~~~ 木水の云彩 认识自我、超越自我 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我CSDN：admin_zlj QQ：1759629281 （嘀嘀嘀~，麻烦让一下，我要开车了！） 本站建于： 2022 - 03 - 23 上线时间：2022 - 03 - 29"},{"title":"archives","date":"2022-03-26T13:42:03.000Z","updated":"2022-03-28T13:42:48.352Z","comments":true,"path":"archives/index.html","permalink":"https://admin-zlj.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-24T07:12:19.000Z","updated":"2022-03-28T13:42:15.717Z","comments":false,"path":"categories/index.html","permalink":"https://admin-zlj.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-03-28T14:17:49.000Z","updated":"2022-03-28T13:40:21.286Z","comments":true,"path":"link/index.html","permalink":"https://admin-zlj.github.io/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-03-26T02:11:28.000Z","updated":"2022-03-28T13:42:02.440Z","comments":false,"path":"comments/index.html","permalink":"https://admin-zlj.github.io/comments/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2022-03-28T08:14:00.000Z","updated":"2022-03-28T13:03:04.279Z","comments":true,"path":"music/index.html","permalink":"https://admin-zlj.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-24T07:14:39.000Z","updated":"2022-03-28T13:41:10.176Z","comments":false,"path":"tags/index.html","permalink":"https://admin-zlj.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-03-31T03:45:50.584Z","updated":"2022-03-31T03:45:50.584Z","comments":false,"path":"List/gallery/index.html","permalink":"https://admin-zlj.github.io/List/gallery/index.html","excerpt":"","text":"Dragon_Ball 龙珠の4k高清壁纸 Marvel 漫威4kの壁纸 壁紙 木水の高清壁纸"},{"title":"Music-音乐","date":"2022-03-28T10:58:56.000Z","updated":"2022-03-28T11:20:00.644Z","comments":false,"path":"List/music/index.html","permalink":"https://admin-zlj.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-28T11:41:10.000Z","updated":"2022-03-28T12:26:52.889Z","comments":false,"path":"List/movies/index.html","permalink":"https://admin-zlj.github.io/List/movies/index.html","excerpt":"","text":"视频"},{"title":"","date":"2022-03-28T13:56:14.000Z","updated":"2022-03-29T07:40:17.571Z","comments":false,"path":"List/gallery/DragonBall/index.html","permalink":"https://admin-zlj.github.io/List/gallery/DragonBall/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-28T14:50:13.000Z","updated":"2022-03-29T14:43:26.906Z","comments":false,"path":"List/gallery/Marvel/index.html","permalink":"https://admin-zlj.github.io/List/gallery/Marvel/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-28T14:50:13.000Z","updated":"2022-03-29T09:11:40.000Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://admin-zlj.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"最全的—— ES6有哪些新特性？","slug":"最全的—— ES6有哪些新特性？","date":"2022-04-20T04:00:00.000Z","updated":"2022-04-20T02:59:15.043Z","comments":true,"path":"posts/66744729.html","link":"","permalink":"https://admin-zlj.github.io/posts/66744729.html","excerpt":"","text":"ES6新特性1、let和const前面讲过：https://blog.csdn.net/ZLJ_999/article/details/123960186 2、symbolSymbol是ES6中引入的一种新的基本数据类型，用于表示一个独一无二的值，不能与其他数据类型进行运算。它是JavaScript中的第七种数据类型，与undefined、null、Number（数值）、String（字符串）、Boolean（布尔值）、Object（对象）并列。 你可以这样创建一个Symbol值： const a = Symbol(); console.log(a); //Symbol() //因为Symbol是基本数据类型，而不是对象，不能 new 。 const a = new Symbol();//报错，Symbol is not a constructor 使用Symbol()创建一个Symbol类型的值并赋值给a变量后，你就得到了一个在内存中独一无二的值。现在除了通过变量a，任何人在任何作用域内都无法重新创建出这个值 const a = Symbol(); const b = Symbol(); 内存解构图 3、模板字符串 在ES6之前，处理模板字符串： 通过“\\”和“+”来构建模板 对ES6来说:用${}来界定；反引号(``)直接搞定；&lt;script&gt; url=\"xxxxxx\" // es6之前 let html=\"&lt;div&gt;\"+ \" &lt;a&gt;\"+url+\"&lt;/a&gt;\"+ \"&lt;/div&gt;\"; //es6 let eshtml=`&lt;div&gt; &lt;a&gt;${url}&lt;/a&gt; &lt;/div&gt;` &lt;/script&gt; 非常好用3.1 字符串新方法（补充） includes()判断字符串是否包含参数字符串，返回boolean值。 startsWith() / endsWith()，判断字符串是否以参数字符串开头或结尾。返回boolean值。这两个方法可以有第二个参数，一个数字，表示开始查找的位置。let str = 'blue,red,orange,white'; str.includes('blue');//true str.startsWith('blue');//true str.endsWith('blue');//false repeat()方法按指定次数返回一个新的字符串。console.log('hello'.repeat(2)); //'hellohello' padStart()/padEnd()，用参数字符串按给定长度从前面或后面补全字符串，返回新字符串。let arr = 'hell'; console.log(arr.padEnd(5,'o')); //'hello' console.log(arr.padEnd(6,'o')); //'helloo' console.log(arr.padEnd(6)); //'hell ',如果没有指定将用空格代替 console.log(arr.padStart(5,'o')); //'ohell' 4、解构表达式解构赋值是对赋值运算符的扩展。它是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。字符串、以及ES6新增的Map和Set 都可以使用解构表达式 4.1 数组解构let [a,b,c] = [1,2,3]; console.log(a,b,c); //1,2,3 let [a,b,c] = [1,,3]; console.log(a,b,c); //1,undefined,3 let [a,,b] = [1,2,3]; console.log(a,b);//1,3 let [a,..b] = [1,2,3]; //...是剩余运算符，表示赋值运算符右边除第一个值外剩余的都赋值给b console.log(a,b);//1,[2,3] 4.2 对象解构对象的解构赋值和数组类似，不过左边的变量名需要使用对象的属性名，并且用大括号{}而非中括号[] let obj = { name: \"ren\", age: 12, sex: \"male\" }; let { name, age, sex } = obj; console.log(name, age, sex); //'ren' 12 'male' let { name: myName, age: myAge, sex: mySex } = obj; //自定义变量名 console.log(myName, myAge, mySex); //'ren' 12 'male' 5、对象方面5.1 Map和Set Map和Set属于es6新增加的对象 5.1.1 MapMap对象用于保存键值对，任何值JavaScript支持的值都可以作为一个键（key）或者一个值（value）。与对象不同的是 object的键只能是字符串或ES6的symbol值，而Map可以是任何值。 Map对象有一个size属性，存储了键值对的个数，而object对象没有类似属性。let myMap = new Map([['name','ren'],['age',12]]); console.log(myMap); //{'name'=&gt;'ren','age'=&gt;12} myMap.set('sex','male'); console.log(myMap); //{'name'=&gt;'ren','age'=&gt;12,'sex'=&gt;'male'} console.log(myMap.size); //3 myMap.get('name'); //'ren' myMap.has('age'); //true myMap.delete('age'); //true myMap.has('age'); //false myMap.get('age'); //undefined 5.1.2 Set可以理解为后端的Set集合对象Set对象和Map对象类似，但它存储不是键值对。类似数组，但它的每个元素都是唯一的。let mySet = new Set([1,2,3]);//里面要传一个数组，否则会报错 console.log(mySet); //{1,2,3} mySet.add(4); console.log(mySet); //{1,2,3,4} mySet.delete(1); //true mySet.has(1); //false console.log(mySet); //{2,3,4} 利用Set对象唯一性的特点，可以轻松实现数组的去重 let arr = [1,1,2,3,4,4]; let mySet = new Set(arr); let newArr = Array.from(mySet); console.log(newArr); //[1,2,3,4] 5.3 数组的新方法 新增的方法有： Array.from()是内置对象Array的方法，实例数组不能调用 includes() 参数：数值 ——– 返回值：true/false map()、filter() 参数：函数——– 返回值：数组 forEach() 参数：函数——– 返回值：undefined find() 参数：函数——– 返回值：数值 some()、every() 参数：函数——– 返回值：true/false 5.3.1 Array.from()方法 Array.from()方法可以将可迭代对象转换为新的数组。 函数可接受3个参数（后两个参数可以没有）： 第一个表示将被转换的可迭代对象(如果只有一个参数就是把形参转变成数组) 第二个是回调函数，将对每个数组元素应用该回调函数，然后返回新的值到新数组， 第三个是回调函数内this的指向。 let arr = [1, 2, 3]; let obj = { double(n) { return n * 2; } } console.log(Array.from(arr, function (n){ return this.double(n); }, obj)); // [2, 4, 6] 5.3.2 includes()方法参数：数值 ——– 返回值：true/falseincludes()方法——是查看数组中是否存在这个元素，存在就返回true,不存在就返回false let arr = [1,33,44,22,6,9] let ary = arr.includes(22) console.log(ary) 5.3.3 map()、filter() 方法参数：函数——– 返回值：数组 map()方法—–要利用原数组经过运算后的数组，或者从对象数组中拿某个属性 filter()方法——是将符合挑选的筛选出来成为一个新数组，新数组不会影响旧数组。 &lt;script&gt; let arr = [1, 33, 44, 2, 6, 9]; let newarr1 = arr.filter((v) =&gt; v &gt; 10); //newarr1-------[33, 44] let newarr2 = arr.filter((v) =&gt; v * 2); //newarr2-------[1, 33, 44, 2, 6, 9] let newarr3 = arr.map((v) =&gt; v &gt; 10); //newarr3-------[false, true, true, false, false, false] let newarr4 = arr.map((v) =&gt; v * 2); //newarr4------- [2, 66, 88, 4, 12, 18] &lt;/script&gt; 5.3.4 forEach()方法参数：函数——– 返回值：undefined forEach() 方法——是循环遍历数组中的每一项，没有返回值 find()方法———是查找数组中符合条件的第一个元素，直接将这个元素返回出来 let arr = [1,33,44,2,6,9] let a1= [] arr.forEach((v, i)=&gt;{ if (v &gt; 10) { a1.push(arr[i]) } }) console.log(a1) [33,44] let a2= arr.find(v =&gt; v &gt; 10) console.log(a2) 5.3.4 find()方法参数：函数——– 返回值：数值 find()方法———-是查找数组中符合条件的第一个元素，直接将这个元素返回出来 let arr = [1,33,44,2,6,9] let a= arr.find(v =&gt; v &gt; 10) console.log(a) // 33 5.3.6 some()、every() 方法参数：函数——– 返回值：true/false some()方法——找到一个符合条件的就返回true,所有都不符合返回false。every()方法——数组所有值都符合条件才会返回true,有一个不符合返回false。 let arr = [1,2,3,4,6,11] let newarr = arr.some(function(v){ return v &gt; 10 }) console.log(newarr) //true let newarr2 = arr.every(function(v){ return v &gt; 10 }) console.log(newarr2) //false 5.4 object的新方法在 ES6 中，添加了Object.is()、Object.assign()、Object.keys()、Object.values()、Object.entries()等方法。 5.4.1 Object.is() Object.is()方法用来判断两个值是否为同一个值，返回一个布尔类型的值。 const obj1 = {}; const obj2 = {}; console.log(Object.is(obj1, obj2)); // false const obj3 = {}; const value1 = obj3; const value2 = obj4; console.log(Object.is(value1, value2)); // true 5.4.2 Object.assign() Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象。——难理解看实例 对象合并 const obj1 = { a: 1 }; const obj2 = { b: 2 }; const obj3 = { a:5 , c: 3 }; //对象合并，把后面对像合并到第一个对象，对象里相同的属性会覆盖 Object.assign(obj1, obj2, obj3); console.log(obj1); // { a: 5, b: 2 , c:3} 5.4.3 Object.keys()、Object.values()、Object.entries() Object.keys() 返回对象所有属性 Object.values() 返回对象所有属性值 Object.entries() 返回多个数组，每个数组是 key–value不解释直接看例子&lt;script&gt; let person = { name: \"admin\", age: 12, language: [\"java\", \"js\", \"css\"], }; console.log(Object.keys(person)); //[ 'name', 'age', 'language' ] console.log(Object.values(person)); //[ 'admin', 12, [ 'java', 'js', 'css' ] ] console.log(Object.entries(person)); /* [ [\"name\", \"admin\"], [\"age\", 12], [\"language\", [\"java\", \"js\", \"css\"]], ]; */ &lt;/script&gt; 5.5 对象声明简写&lt;script&gt; let name ='admin' let age = 20 //es6之前 // let person={ // name:name, // age:age // } //es6 声明对象时的属性名与引用的变量名相同就可以省略 let person={ name, age } &lt;/script&gt; 5.6 …(对象扩展符) 拷贝对象（深拷贝）&lt;script&gt; let person={ name: \"admin\", age: 12, wife:{ name:\"迪丽热巴\" } } let person2={...person} console.log(person2===person);//false console.log(person2);//{name: 'admin', age: 12, wife: {…}} &lt;/script&gt; 合并对象&lt;script&gt; const obj1 = { a: 1 }; const obj2 = { b: 2 }; const obj3 = { a: 5, c: 3 }; let newObj ={...obj1,...obj2,...obj3} console.log(newObj); // { a: 5, b: 2 , c:3} &lt;/script&gt; 6、函数方面6.1 参数默认值&lt;script&gt; // es6之前 // function add(a, b) { // if(!a) a=0 // if(!b) b=0 // return a + b; // } //es6 function add(a = 0, b = 0) { return a + b; } let x=add(); let y=add(2); let z=add(3, 4); console.log(x,y,z); //x=0, y=2, z=7 &lt;/script&gt; 6.2 箭头函数箭头函数实现了一种更加简洁的书写方式。箭头函数内部没有arguments，也没有prototype属性，所以不能用new关键字调用箭头函数。let add = (a,b) =&gt; { return a+b; } let print = () =&gt; { console.log('hi'); } let fn = a =&gt; a * a; //当只有一个参数时，括号可以省略，函数体只有单行return语句时，大括号也可以省略。 6.3 箭头函数和普通函数最大的区别在于其内部this永远指向其父级对象的this。(重点) var age = 123; let obj = { age:456, say:() =&gt; { console.log(this.age); //this指向window } }; obj.say(); //123 7、class（类） class 作为对象的模板被引入ES6，你可以通过 class 关键字定义类。class 的本质依然是一个函数。 创建类&lt;script&gt; class person { //关键字声明方式 constructor(name) { this.name=name } say() { console.log(\"hello\"); } } var p = new person('p'); p.say(); //'hello' console.log(p.name); &lt;/script&gt; 类的继承类的继承通过extends关键字实现。子类必须在constructor中调用super()&lt;script&gt; class Person { constructor(name, age) { this.name = name; this.age = age; } say() { console.log(this.name + \":\" + this.age); } } class Student extends Person { constructor(name, age, sex) { super(name, age); this.sex = sex; } } var student = new Student(\"admin\", 12, \"male\"); student.name; //'admin' student.sex; //'male' student.say(); //'ren:12' &lt;/script&gt; 8、promise和proxy讲不清楚，等我学会了，后面在讲9、模块化 导入 ES6使用关键字 import 导入模块（文件），有两种常用的方式：import ‘模块名称’ from ‘路径’； import ‘路径’； 导出 ES6 通过 export 和export default 导出模块。 let name = 'ren',age = 12; export {name,age}; //注意：变量需要用大括号包裹，然后才能向外输出 模块化优点 1.防止命名冲突 2.复用性强 若本文对你有帮助 点个赞 点个关注 总结——ES6思维导图","categories":[{"name":"es6","slug":"es6","permalink":"https://admin-zlj.github.io/categories/es6/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"es6","slug":"es6","permalink":"https://admin-zlj.github.io/tags/es6/"}]},{"title":"前端——谈谈js对象的深复制与浅复制","slug":"前端——谈谈js对象的深复制与浅复制","date":"2022-04-20T03:00:00.000Z","updated":"2022-04-20T02:59:15.040Z","comments":true,"path":"posts/ca73cfc.html","link":"","permalink":"https://admin-zlj.github.io/posts/ca73cfc.html","excerpt":"","text":"若本文对你有帮助 – 请点个赞或者关注吧 1、引用赋值——浅复制 缺点：改变复制的对象时，原对象也改变（实际是同一对象） var obj1={ name:\"admin\", age:100 } var obj2=obj1 //只是把obj1指向堆内存的地址赋值给obj2 obj2.name = 'zlj' console.log(obj1,obj2); 直接赋值时，obj1只是把指向堆内存的地址赋值给obj2，指向的还是同一个对象，因此改变obj2.name时，实际上改变的也是obj1 2、es6 …扩展符 —— 深复制（有缺陷） 优点：这种复制方式不会改变原对象 var obj1={ name:\"admin\", age:100 } var obj2={...obj1} obj2.name = 'zlj' //当我们改变obj2.name时，obj1没有被改变 console.log(obj1,obj2); 缺点：当对象里面在嵌套一个对象时，对内部对象的复制是浅复制 var obj1={ name:\"admin\", age:100, move:{like:'吃',sport:'篮球'} } var obj2={...obj1} obj2.name = 'zlj' obj2.move.like=\"喝\" console.log(obj1,obj2); 结果：改变的name没有影响原对象，但是内部的move对象是有影响的es6 …扩展符这种方式也只是比浅复制多复制一层 3、json-parse json-stringify方式——深复制（有缺陷） 优点：可以实现多层深复制 var obj1={ name:\"admin\", age:100, move:{ like:'吃', sport:'篮球' } } //JSON.stringify()把对象转化成json字符串 //JSON.parse()把json字符串还原成对象 var obj2=JSON.parse(JSON.stringify(obj1)) obj2.name = 'zlj' obj2.move.like=\"喝\" console.log(obj1,obj2); 缺点：值为undefined的属性无法复制 var obj1={ name:\"admin\", age:100, sex:undefined, move:{ like:'吃', sport:'篮球' } } var obj2=JSON.parse(JSON.stringify(obj1)) obj2.name = 'zlj' obj2.move.like=\"喝\" console.log(obj1,obj2); 当sex的值undefined时，sex属性就没有被复制到obj2 总结平时练习时，我们的数据不会很复杂，在实际开发中才会有非常复杂数据，这是我们就需要用到第三方的库来解决深复制问题。","categories":[{"name":"JavaScript从入门到高级笔记","slug":"JavaScript从入门到高级笔记","permalink":"https://admin-zlj.github.io/categories/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://admin-zlj.github.io/tags/JavaScript/"}]},{"title":"React创建项目报错：You are running `create-react-app` 5.0.0, which is behind the latest release (5.0.1).","slug":"React创建项目报错：You are running `create-react-app` 5.0.0, which is behind the latest release (5.0.1).","date":"2022-04-14T06:00:00.000Z","updated":"2022-04-14T06:12:44.182Z","comments":true,"path":"posts/886e11b8.html","link":"","permalink":"https://admin-zlj.github.io/posts/886e11b8.html","excerpt":"","text":"使用React脚手架创建项目，报错：create-react-app app2 ​ 如果您之前已create-react-app通过 全局安装npm install -g create-react-app 意思是有新版本了，之前安装的版本低了 1.可以先卸载npm uninstall -g create-react-app 2.然后再使用npx临时安装：npx create-react-app my-app 3.如果还不行就加上版本号npx create-react-app@5.0.1 yourApp","categories":[{"name":"React","slug":"React","permalink":"https://admin-zlj.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://admin-zlj.github.io/tags/React/"},{"name":"bug","slug":"bug","permalink":"https://admin-zlj.github.io/tags/bug/"}]},{"title":"react跨域 http-proxy-middleware 无效还是404","slug":"react跨域 http-proxy-middleware 无效还是404","date":"2022-04-14T04:00:00.000Z","updated":"2022-04-14T06:15:05.614Z","comments":true,"path":"posts/9068ab30.html","link":"","permalink":"https://admin-zlj.github.io/posts/9068ab30.html","excerpt":"","text":"问题描述： 今天用http-proxy-middleware的过程中，setupProxy.js文件配置好以后发出请求依然无效还是404 ​ setupProxy.js文件 const { createProxyMiddleware } = require(\"http-proxy-middleware\"); module.exports = function (app) { console.log(app); app.use( \"/ajax\", createProxyMiddleware({ target: \"https://i.maoyan.com\", changeOrigin: true, }) ); }; 请求axios({ method: \"get\", url: \"/ajax/comingList?ci=236&amp;limit=10&amp;movieIds=&amp;token=&amp;optimus_uuid=53D982E0BB3411EC8ECD334B3F83289E1602AC03A72F45D3BF85074D843147F0&amp;optimus_risk_level=71&amp;optimus_code=10\", }).then((res) =&gt; { console.log(res); }); 解决办法1.首先看看是不是没有重启服务 2.如果重启还是没有解决 打开package.js 看一下react-scripts的版本如果低于2.0的话http-proxy-middleware是不支持的，我的就是版本太低， 改成了4.0版本就能请求成功了 ​ ​","categories":[{"name":"React","slug":"React","permalink":"https://admin-zlj.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://admin-zlj.github.io/tags/React/"},{"name":"bug","slug":"bug","permalink":"https://admin-zlj.github.io/tags/bug/"}]},{"title":"React创建项目出现ReactDOM.render is no longer supported in React 18警告，index.js修改","slug":"React创建项目出现ReactDOM.render is no longer supported in React 18警告，index.js修改","date":"2022-04-11T04:00:00.000Z","updated":"2022-04-14T06:11:52.238Z","comments":true,"path":"posts/f31fcb1e.html","link":"","permalink":"https://admin-zlj.github.io/posts/f31fcb1e.html","excerpt":"","text":"当你第一次安装 React 18 时，你会在控制台中看到一个警告：因为在 React 18 中，ReactDOM.render 被废弃，当前发出警告，并以兼容模式运行。只需要更改index.js文件即可 改成下面这样警告就会消失: import ReactDOM from \"react-dom/client\"; import App from \"./App\"; const root = ReactDOM.createRoot(document.getElementById(\"root\")); root.render(&lt;App /&gt;); 废弃的方法还有很多 react-dom:ReactDOM.render已弃用。使用它会警告并在 React 17 模式下运行您的应用程序。 react-dom:ReactDOM.hydrate已弃用。使用它会警告并在 React 17 模式下运行您的应用程序。 react-dom:ReactDOM.unmountComponentAtNode已弃用。 react-dom:ReactDOM.renderSubtreeIntoContainer已弃用。 react-dom/server:ReactDOMServer.renderToNodeStream已弃用。 具体参考官网：https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#updates-to-client-rendering-apis 关注我！！！关注我！！！关注我！！！","categories":[{"name":"React","slug":"React","permalink":"https://admin-zlj.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://admin-zlj.github.io/tags/React/"},{"name":"bug","slug":"bug","permalink":"https://admin-zlj.github.io/tags/bug/"}]},{"title":"我的JavaScript笔记——四、IIFE","slug":"我的JavaScript笔记——四、IIFE","date":"2022-04-05T12:00:00.000Z","updated":"2022-04-06T07:26:26.910Z","comments":true,"path":"posts/4f36c419.html","link":"","permalink":"https://admin-zlj.github.io/posts/4f36c419.html","excerpt":"","text":"一、IIFEIIFE 全称：Immediately-Invoked Function Expression （立即调用函数表达式），别名：匿名函数自调用。作用： 隐藏内部实现 不会污染外部（全局）命名空间 用它来编码js模块 &lt;script&gt; (function(){ //匿名函数自调用 var a = 3; console.log(a+3); })(); var a = 4; console.log(a); (function(){ var a = 1; function test(){ console.log(++a); } window.$ = function(){ //向外暴露一个全局函数 return{ test:test } }; })(); $().test(); //$是一个函数 //$执行后返回的是一个对象 &lt;/script&gt;","categories":[{"name":"JavaScript从入门到高级笔记","slug":"JavaScript从入门到高级笔记","permalink":"https://admin-zlj.github.io/categories/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://admin-zlj.github.io/tags/JavaScript/"}]},{"title":"我的JavaScript笔记——三、事件对象event和 this关键字","slug":"我的JavaScript笔记——三、事件对象event和 this关键字","date":"2022-04-05T07:00:00.000Z","updated":"2022-04-06T07:26:18.040Z","comments":true,"path":"posts/96b2360e.html","link":"","permalink":"https://admin-zlj.github.io/posts/96b2360e.html","excerpt":"","text":"一、事件对象event1.1 什么是事件对象？ Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 上面是官方说法，简单的说就是当你触发了一个事件以后，event对象存放了对该事件的一些描述信息。 列如： var box = document.querySelector('.box') box.onclick = function fn1(event){ console.log(event.x) // 返回鼠标所点击位置的 X轴坐标点信息 console.log(event.y) // 返回鼠标所点击位置的 Y轴坐标点信息 } 这是鼠标点击事件 其实还存放了点击时相对浏览器窗口的坐标以及相对整个页面的坐标等等。 如果是 键盘事件 哪个键被摁下也会在event对象中如果是 鼠标滚轮事件 滚轮滑动距离也event对象中 二、this 关键字 在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。this会变化就是它麻烦的原因 首先声明this在如何时候都指向一个对象 2.1 在函数中，this 表示全局对象。 当调用函数时，函数内部会传入一个隐含的参数，这个隐含参数也就是this function f(){ console.log(this); //此时的this就指向window对象 } f() //实质上window.f() 2.2 在方法中，this 表示该方法所属的对象。var obj = { name:'admin', sayName(){ console.log(this.name);//此时的this就指向obj对象 } }; obj.sayName(); //输出admin 2.3 在事件中，this 表示接收事件的元素。&lt;button onclick=\"this.style.display='none'\"&gt; 点我后我就消失了 &lt;/button&gt; //此时的this就指向button这个元素对象 2.4 call() 和 apply() 方法可以将 this 引用到任何对象。var p1 = { name: \"我是p1的name\", sayName: function () { console.log(this.name); } }; var p2 = { name: \"我是p2的name\", }; p1.sayName();//此时的this就指向p1对象 p1.sayName.call(p2);//此时的this就指向p2对象 p1.sayName.apply(p2);//此时的this就指向p2对象 2.5 总结 谁调用了函数，this就是谁。 没有人调用this就指向window。 call()和apply()可以改变this指向。","categories":[{"name":"JavaScript从入门到高级笔记","slug":"JavaScript从入门到高级笔记","permalink":"https://admin-zlj.github.io/categories/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://admin-zlj.github.io/tags/JavaScript/"}]},{"title":"我的JavaScript笔记——二、事件的冒泡和捕获（重点）及如何取消冒泡","slug":"我的JavaScript笔记——二、事件的冒泡和捕获（重点）及如何取消冒泡","date":"2022-04-05T05:00:00.000Z","updated":"2022-04-06T07:25:44.745Z","comments":true,"path":"posts/9202e118.html","link":"","permalink":"https://admin-zlj.github.io/posts/9202e118.html","excerpt":"","text":"二、事件的冒泡和捕获（重点）1.什么是事件？ 简单来说：就是用户与浏览器窗口发生交互的过程。列如：鼠标点击、鼠标滑入滑出、滚轮、键盘输入…… 2.事件的冒泡以烂大街的点击事件为例（代码简单就不写了看着也烦） 2.1 什么是事件冒泡？ 即当发生事件时，由最内部的元素接收，然后逐级向上传播。 看上图当我们点击 a 时a 会先响应并触发点击事件然后 p 响应并触发点击事件然后是 li =&gt; ul =&gt; body =&gt; html 逐级向上这个过程就是事件的冒泡 2.2 什么是事件捕获？ 即当发生事件时，由最外部的元素接收，然后逐级向下传播。 捕获就是冒泡相反当我们点击 a 时最外层的 html 会先响应并触发点击事件然后 body 响应并触发点击事件然后是 ul =&gt; li =&gt; p =&gt; a 逐级向下这个过程就是事件的捕获 2.3 如何取消冒泡呢？浏览器默认情况下是会冒泡的，当我们需要取消时， 方法一： 在定义的事件回调函数的后面加上 return false a.onclick = function(){ alert('a被点击了'); return false; } 方法二：通过事件对象 event取消 a.onclick = function(event){ alert('a被点击了'); event. cancelBubble=true; }","categories":[{"name":"JavaScript从入门到高级笔记","slug":"JavaScript从入门到高级笔记","permalink":"https://admin-zlj.github.io/categories/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://admin-zlj.github.io/tags/JavaScript/"}]},{"title":"我的JavaScript笔记—— 一、var、let、const的区别?","slug":"我的JavaScript笔记——一、var、let、const的区别","date":"2022-04-05T04:00:00.000Z","updated":"2022-04-05T04:44:20.958Z","comments":true,"path":"posts/2112bcd5.html","link":"","permalink":"https://admin-zlj.github.io/posts/2112bcd5.html","excerpt":"","text":"什么是JavaScript？首先,ECMAScript 和 JavaScript 什么关系？ ECMAScript是一个国际通过的标准化脚本语言。 JavaScript由ECMAScript和DOM、BOM三者组成。 可以简单理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。 一、var、let、const的区别1. var声明变量存在变量提升，let和const不存在变量提升console.log(a); // undefined ===&gt; a已声明还没赋值，默认得到undefined值 console.log(b); // 报错：b is not defined ===&gt; 找不到b这个变量 console.log(c); // 报错：c is not defined ===&gt; 找不到c这个变量 var a = 100; let b = 10; const c = 10; console.log(a);//a=100 2. let和const只能在块作用域里访问if(1){ var a = 100; let b = 10; const c = 1; } console.log(a); // 100 console.log(b) // 报错：b is not defined ===&gt; 找不到b这个变量 console.log(c) // 报错：c is not defined ===&gt; 找不到c这个变量 3. 同一作用域下let和const不能声明同名变量，而var可以var a = 100; console.log(a); //控制台输出 100 var a = 10; console.log(a); //控制台输出 10 let a = 100; let a = 10; // 控制台报错：Identifier 'a' has already been declared ===&gt; 标识符a已经被声明了。 4. const定义常量，而且不能修改，但是在定义的对象时对象属性值可以改变const a=2 a=3 console.log(a) //控制台报错 const person = { name : 'make', sex : '男' } person.name = 'test' console.log(person.name) //运行发现控制台没有报错，且 person.name 被成功修改 ？？？？这是怎么回事呢？ 因为对象是引用类型的，person中保存的仅是对象的指针，而修改对象的属性不会改变对象的指针，所以这种情况就会修改成功。也就是说const定义的引用类型只要指针不发生改变，都是被允许的。 接下来我们试着修改一下指针，让person指向一个新对象，最后果然报错 const person = { name : 'make', sex : '男' } person = { name : 'test', sex : '男' } console.log(person.name) //控制台报错 5. 小结 var定义的变量，变量提升，没有块的概念，可以跨块访问。 let定义的变量，只能在块作用域里访问，不能声明同名变量。 const用来定义常量，使用时必须初始化(即必须赋值)，不能声明同名变量，只能在块作用域里访问，而且不能修改，但是在定义的对象时对象属性值可以改变。 他们都不能跨函数访问","categories":[{"name":"JavaScript从入门到高级笔记","slug":"JavaScript从入门到高级笔记","permalink":"https://admin-zlj.github.io/categories/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://admin-zlj.github.io/tags/JavaScript/"}]},{"title":"前端初学者node会这些就可以了 Nodejs入门","slug":"nodejs","date":"2022-03-30T14:00:00.000Z","updated":"2022-03-30T14:52:29.717Z","comments":true,"path":"posts/9917d3f9.html","link":"","permalink":"https://admin-zlj.github.io/posts/9917d3f9.html","excerpt":"","text":"Nodejs一、Nodejs介绍与安装 介绍： Node 是一个让 JavaScript 运行在服务端的开发平台。 简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 总而言之：Node.js是可以脱离浏览器环境运行的JavaScript程序，且基于V8 引擎下载地址： http://nodejs.cn/安装：默认安装，无脑下一步查看是否安装成功： node -v 再命令行执行命令，如果出现版本号即为安装成功 二、Nodejs入门1.运行的JavaScript程序1、创建 helloworld.js console.log('Hello World!!!') 2、命令行执行命令 node helloworld.js 运行结果：hello world!! 2.Node安装依赖包命令： npm install 依赖包名 示例： npm install mysql (安装mysql依赖) npm install vue (安装vue依赖) 三、Node 实现请求响应（模拟Taomcat服务器）1、创建 httpserver.js ； // require是导入模块，这个模块是node内置模块,也可以是自定义模块 const http = require('http'); // 创建一个httpserver服务 http.createServer(function(request,response){ //浏览器将 以text-plain去解析数据。 response.writeHead(200,{'Content-type':'text/plain'}); // 浏览器输出的内容 response.end(\"&lt;h1&gt;hello word!!!&lt;/h1&gt;\"); }).listen(8888);// 监听端口8888 console.log(\"http://localhpst:8888 启动成功!!\"); 2、运行服务器程序； node httpserver.js 3、在浏览器中输入：http://localhost:88884、停止服务：ctrl + c 浏览器显示：hello word!!!","categories":[{"name":"笔记","slug":"笔记","permalink":"https://admin-zlj.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node.js","slug":"node-js","permalink":"https://admin-zlj.github.io/tags/node-js/"}]},{"title":"初学者福音 轻松拿捏Flex布局，附有九宫格案列","slug":"felx布局","date":"2022-03-30T10:00:00.000Z","updated":"2022-03-30T09:32:55.602Z","comments":true,"path":"posts/e2294b51.html","link":"","permalink":"https://admin-zlj.github.io/posts/e2294b51.html","excerpt":"","text":"传统布局 基于盒状模型，依赖 display属性 + position属性 + float属性 对于那些特殊布局非常不方便，例如：垂直居中就不容易实现。 Flex布局 Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局。 采用Flex布局的元素，称为Flex容器。所有子元素为容器成员，称为flex item。 容器默认存在两根轴：水平的主轴（main axis）和垂直交叉轴（cross axis）。 为了方便理解 我称水平主轴为横轴，垂直交叉轴为竖轴 主轴的开始位置(如图) ：main start，结束位置：main end； 垂直交叉轴的开始位置：cross start，结束位置：cross end。（项目默认沿主轴排列） 单个项目占据的主轴空间：main size，占据的交叉轴空间：cross size。 一. 容器(flex-container)的属性以下6个属性是设置在容器上的。（注意：是flex-container的属性，不是flex-item的属性） flex-direction flex-wrap flex-flow justify-content align-items align-content 1.1 flex-direction属性flex-direction属性决定横轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse; } row（默认值）：横轴为水平方向，起点在左端。 row-reverse：横轴为水平方向，起点在右端。 column：横轴为垂直方向，起点在上沿。 column-reverse：横轴为垂直方向，起点在下沿。 1.2 flex-wrap属性默认情况下，flex-item都排在一条线上。flex-wrap属性决定是否换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } nowrap（默认）：不换行 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 nowrap（默认）： wrap：wrap-reverse： 1.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。也就是说为了方便flex-flow可以同时控制这两种属性(具体传参形式比较繁琐，不推荐) .box { flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; } 1.4 justify-content属性justify-content属性定义了flex-item在横轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 1.5 align-items属性align-items属性定义项目在竖轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } flex-start：竖轴的起点对齐。 flex-end：竖轴的终点对齐。 center：竖轴的中点对齐。 baseline: flex-item 的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 二、项目(flex-item)的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 2.1 order属性order属性定义flex-item的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: &lt;integer&gt;; } 2.2 flex-grow属性flex-grow属性定义flex-item的放大比例，默认为0。 .item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 2.3 flex-shrink属性flex-shrink属性定义了flex-item的缩小比例，默认为1。**(负值对该属性无效。)**与放大类似，不赘述 .item { flex-shrink: &lt;number&gt;; /* default 1 */ } 2.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。简单的说就是设置flex-item的宽度 flex布局中宽度的优先级:min-width/max-width &gt; flex-basis &gt; width &gt; 内容支撑 .item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 2.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写。**(具体传参形式比较繁琐，不推荐)** .item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] } 2.6 align-self属性align-self属性允许单个flex-item有与其他项目不一样的对齐方式，可覆盖align-items属性。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 取值与align-items相同 ​ 三、九宫格案列 学过flex布局，九宫格轻轻松松搞定！position，float 都不需要 相对于传统布局真的方便很多 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .flex-box { width: 500px; height: 500px; background-color: red; display: flex; flex-wrap: wrap; justify-content: space-evenly; align-content:space-evenly; } .flex-item { width: 150px; height: 150px; } .blue { background-color: blue; } .green { background-color: green; } .orange { background-color: orange; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"flex-box\"&gt; &lt;div class=\"flex-item orange\"&gt;&lt;/div&gt; &lt;div class=\"flex-item green\"&gt;&lt;/div&gt; &lt;div class=\"flex-item blue\"&gt;&lt;/div&gt; &lt;div class=\"flex-item green\"&gt;&lt;/div&gt; &lt;div class=\"flex-item blue\"&gt;&lt;/div&gt; &lt;div class=\"flex-item orange\"&gt;&lt;/div&gt; &lt;div class=\"flex-item blue\"&gt;&lt;/div&gt; &lt;div class=\"flex-item orange\"&gt;&lt;/div&gt; &lt;div class=\"flex-item green\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 总结 本文参考菜鸟https://www.runoob.com/w3cnote/flex-grammar.html 编写，其中加入一些自己的想法，也有许多不同，也更加方便初学者理解","categories":[{"name":"笔记","slug":"笔记","permalink":"https://admin-zlj.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"html","slug":"html","permalink":"https://admin-zlj.github.io/tags/html/"},{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"https://admin-zlj.github.io/tags/css/"},{"name":"flex","slug":"flex","permalink":"https://admin-zlj.github.io/tags/flex/"}]},{"title":"H5的新特性","slug":"H5新特性","date":"2022-03-30T09:00:00.000Z","updated":"2022-03-30T09:42:08.775Z","comments":true,"path":"posts/d873d49c.html","link":"","permalink":"https://admin-zlj.github.io/posts/d873d49c.html","excerpt":"","text":"HTML5新特性1.HTML5新特性（面试） 1）增加了audio和video音频播放，抛弃了Flash 2）新增了canvas画布（绘画，制作动画（如小游戏开发等）） 3）地理定位 4）增加了离线缓存 5）硬件加速 6）Web Socket（全双工通信） 7）增加了本地存储 8）新增了一些语义化标签 2.网页布局标签 header:页首 nav:导航栏 aside:侧边栏 main:主体 section:区块 article:文章 footer:页尾 3.语义化标签 1)mark:高亮显示(行级) 2)details(描述)与summary(摘要):一般用于名词解释或用于封装一个区块等 3)meter:定义度量衡 属性:value/min/max 4)progress:进度条 属性:value/min/max 5)dialog:对话框或窗口 6)figure:用于对元素进行组合（一般用来组合一张图的标题、图片和图片描述等） 4.HTML5多媒体 1)audio 播放音乐或音频。IE9以下的版本不支持。 a)支持的格式 .mp3/.ogg/.wav b)属性 src:文件路径 autoplay:自动播放 loop:循环 controls:控制条 muted:静音 preload:预加载（当使用autoplay时，preload自动失效） 2)video 加载视频。IE9以下的版本不支持。 a)支持的格式 .mp4/.ogg/.webm b)属性 src:文件路径 autoplay:自动播放 loop:循环 controls:控制条 muted:静音 preload:预加载（当使用autoplay时，preload自动失效） width:宽度 height:高度 poster:海报 3)embed 嵌入内容或加载插件。 属性: src:文件路径 width:宽度 height:高度 type:类型 4)canvas 画布。是一个容器元素。 注意： a.单独使用canvas没有什么意义，它必须结合Javascript使用。它的具体功能体现是通过Javascript体现现来的。 b.canvas的宽高最好不要通过css实现，而是直接使用标签属性width和height实现。 5.HTML5常用属性 1）contentEditable 将标签转换为可编辑状态。可用于所有标签。它的值有true/false。 2）hidden 对元素进行隐藏。一般用来传值或当某个条件成立，执行内容显示。默认值为hidden。 3）data-* 用于存储页面或应用程序的私有自定义数据。一般用于传值。 4）multiple 规定输入域中可选择多个内容。用于表单组件中，如file/select。 5）required 约束表单元互在提交前必须输入值。用于表单组件中，需要结合提交按钮使用。 6）pattern 用于验证输入字段的模式。用于表单组件中，需要结合提交按钮使用。 6.表单组件 1）color：颜色 2）email：邮箱 3）tel：电话号码 4）url：网址 5）number：数字 6）range：范围 7）search：搜索 8）date：日期 9）datetime：日期时间 10）datetime-local：本一日期时间 11）year：年份 12）month：月份 13）time：时间 7.表单属性 1）form-action:修改action数据提交的地方 2）form-enctype:修改表单请求的类型 3）form-method:修改数据提交的方法 4）form:设置表单元素属于哪个表单 5）novalidate:不验证 8.input属性 1）autocomplete:自动完成 用来帮助用户输入，每一次输入的内容，浏览器是否保存输入的值，以备将来使用。值有： on/off，默认为on。 为了保护敏感数据（如用户帐号、密码等），避免本地浏览器对它们不安全存储，一般需要关闭。 2）autofocus:自动获焦 3）step:步长 4）multiple:多选 5）pattern:正则匹配 6）placeholder:输入提示 7）required:必须输入","categories":[{"name":"笔记","slug":"笔记","permalink":"https://admin-zlj.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"html","slug":"html","permalink":"https://admin-zlj.github.io/tags/html/"},{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"css3的新特性","slug":"css3新特性","date":"2022-03-30T09:00:00.000Z","updated":"2022-03-30T09:42:22.006Z","comments":true,"path":"posts/a6d0cf2a.html","link":"","permalink":"https://admin-zlj.github.io/posts/a6d0cf2a.html","excerpt":"","text":"CSS3的新特性1.CSS3是CSS2.1的一个升级版，它是对CSS的一个扩展。 2.CSS3的主要新特性： 1）选择器 2）阴影 3）形状转换（2D &lt;-&gt; 3D） 4）变形 5）动画（过渡动画、帧动画） 6）边框 7）多重背景 8）反射 9）文字 10）颜色函数（rgba/hsl/hsla） 11）滤镜（filter） 12）弹性布局 13）多列布局 14）栅格布局 15）盒模型 16）Web字体 17）媒体查询 3.CSS3不是属于浏览器或同一浏览器的不同版本都支持，所以需要兼容处理，通常的做法就是加厂商前缀。 1）主流浏览器内核（面试点） a)Trident: IE内核 b)Webkit：Chrome和Safari内核 c)Gecko：FireFox内核 d)Blink（是Webkit的一个分支）： Chrome和Opera内核 Tips（技巧）:目前国内的浏览器大多都是双核的（IE内核+Chrome内核） 2）厂商前缀 IE： -ms- Chrome&amp;Safari： -webkit- FireFox： -moz- Opera： -o- 4.CSS3选择器 丰富选择的目的：在标签中减少class和id属性的使用。 1）属性选择器 [属性名] [属性名=属性值] [属性名^=属性值] [属性名$=属性值] [属性名*=属性值] 2）结构性伪类 :first-child :last-child :nth-child(n) :nth-last-child(n) :nth-of-type(n) :nth-last-of-type(n) :only-child :only-of-type :empty 3）目标伪类 :target 4）UI元素状态伪类 :checked (只在Opera浏览器中有效) :disabled :enabled :selection 5）否定伪类 :not() 6）通用兄弟元素选择器 5.CSS3文本 1） 文本阴影（主流浏览器都支持，（IE9以上支持）） text-shadow: 水平偏移距离 垂直偏移距离 [模糊距离] [阴影的尺寸] [颜色] [inset]; 2）文本自动换行（主流浏览器都支持） word-wrap: normal|break-word; 3）单词拆分（主流浏览器都支持） word-break: normal|break-all|keep-all; 4）文本拆分（所有主流浏览器都不支持） text-wrap: normal|none|unrestricted|suppress; 5）文本溢出 a)单行文本溢出（重要） text-overflow: clip|ellipsis|string; a)处理文字溢出样式： width: px/%/em/rem...; white-space: nowrap; /* 为允许折行 */ -ms-text-overflow: ellipsis; /* 处理IE兼容 */ text-overflow: ellipsis; overflow: hidden; b)多行文本溢出（IE9以下的版本不支持，主要是谷歌支持） width: px/%/em/rem...; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 行数; overflow: hidden; 6.CSS3边框 1）圆角边框（掌握） border-radius: 1-4 length|% / 1-4 length|%; 四个方位的词：top-left/top-right/bottom-left/bottom-right 2）边框阴影（IE9以上支持） box-shadow: 水平偏移距离 垂直偏移距离 [模糊距离] [阴影的尺寸] [颜色] [inset]; 3）边框图片(IE11.0及以后版本支持） border-image：图片 向内偏移距离 宽度 图像区域超出边框的距离 重复效果; 重复效果：round/strech/repeat 7.CSS3背景 1）多重背景 background: 背景色 背景图片 平铺方式 位置,背景色 背景图片 平铺方式 位置,… 2）background-size：设定背景图像的尺寸。 background-size: 固定长度|百分比值|cover|contain; 3）background-origin：指定背景图像的位置区域。 background-origin: padding-box|border-box|content-box; 4）background-clip：设定背景的绘制区域。 background-clip: border-box|padding-box|content-box; 5）渐变背景 background-image: 线性渐变｜径向渐变 8.CSS3颜色函数 1）RGBA rgba(r,g,b,a) r:红色 取值范围：0-255/0-100% g:绿色 取值范围：0-255/0-100% b:蓝色 取值范围：0-255/0-100% a:不透明度 取值范围：0-1的一个小数 2）HSL hsl(h,s,l) h:色调 取值范围：0-360 s:饱和度 取值范围：0-100% l:亮度 取值范围：0-100% 3）HSLA hsla(h,s,l,a) h:色调 取值范围：0-360 s:饱和度 取值范围：0-100% l:亮度 取值范围：0-100% a:不透明度 取值范围：0-1的一个小数 9.opacity 调整元素的不透明度，大多数情况下用于做元素的遮罩效果。取值范围：0-1的一个小数 IE8及8以下版本不支持opacity，处理兼容的方式，再添加一行代码来处理不透明度：filter:alpha(opacity=数值） 数值的范围：0-100 10.CSS3渐变 渐变主要用来设置背景或制作三维图。 1）线性渐变 background: linear-gradient(方向或角度, 颜色1 百分比, 颜色2 百分比, …); 方向： to left:从右向左渐变 to right:从左向右渐变 to top:从下向上渐变 to bottom:从上向下渐变 to top left:从右下角向左上角渐变 to top right:从左下角向右上角渐变 to bottom left:从右上角向左下角渐变 to bottom right:从左上角向右下角渐变 角度： 比如45度角，应该表示为：45deg 颜色取值： 1）表示颜色的单词 2）16进制颜色 3）表示颜色的函数（rgb()/rgba()/hsl()/hsla()…) 2）径向渐变(沿半径方向渐变） background: radial-gradient(形状 渐变大小 at 位置,颜色1 百分比, …, 颜色n 百分比); 形状： ellipse:椭圆径向渐变（默认） circle:圆径向渐变 渐变大小： farthest-corner:渐变的半径长度为从圆心到离圆心最远的角（默认） closest-side:渐变的半径长度为从圆心到离圆心最近的边 closest-corner:渐变的半径长度为从圆心到离圆心最近的角 farthest-side:渐变的半径长度为从圆心到离圆心最远的边 位置： center:设置圆心在中心位置（默认） top:设置圆心在顶部位置 bottom:设置圆心在底部位置 at 圆心橫坐标 圆心纵坐标: 设定圆心的位置在指定的（橫坐标，纵坐标）处 3）文字渐变 background-image: 线性渐变或径向渐变; -webkit-background-clip: text; -webkit-text-fill-color: transparent; 11.box-sizing 允许你以某种方式定义某些元素，以适应指定的区域。 box-sizing: content-box/border-box （火狐和谷歌低版本需要厂商前缀）","categories":[{"name":"笔记","slug":"笔记","permalink":"https://admin-zlj.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"html","slug":"html","permalink":"https://admin-zlj.github.io/tags/html/"},{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css3","slug":"css3","permalink":"https://admin-zlj.github.io/tags/css3/"}]},{"title":"我的第一篇博客","slug":"01-我的第一篇博客","date":"2022-03-28T13:00:00.000Z","updated":"2022-03-30T08:59:29.195Z","comments":true,"path":"posts/d95d7e09.html","link":"","permalink":"https://admin-zlj.github.io/posts/d95d7e09.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？作为一个即将工作的大学生，我觉得建一个自己的博客来记录自己的学习过程就很nice！！！ 展望博客我会把自己学习过程的笔记和一些记忆犹新的bug上传到这里来。 拜拜 完结撒花","categories":[{"name":"博主","slug":"博主","permalink":"https://admin-zlj.github.io/categories/%E5%8D%9A%E4%B8%BB/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://admin-zlj.github.io/tags/blog/"}]}],"categories":[{"name":"es6","slug":"es6","permalink":"https://admin-zlj.github.io/categories/es6/"},{"name":"JavaScript从入门到高级笔记","slug":"JavaScript从入门到高级笔记","permalink":"https://admin-zlj.github.io/categories/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/"},{"name":"React","slug":"React","permalink":"https://admin-zlj.github.io/categories/React/"},{"name":"笔记","slug":"笔记","permalink":"https://admin-zlj.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"博主","slug":"博主","permalink":"https://admin-zlj.github.io/categories/%E5%8D%9A%E4%B8%BB/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://admin-zlj.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"es6","slug":"es6","permalink":"https://admin-zlj.github.io/tags/es6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://admin-zlj.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://admin-zlj.github.io/tags/React/"},{"name":"bug","slug":"bug","permalink":"https://admin-zlj.github.io/tags/bug/"},{"name":"node.js","slug":"node-js","permalink":"https://admin-zlj.github.io/tags/node-js/"},{"name":"html","slug":"html","permalink":"https://admin-zlj.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://admin-zlj.github.io/tags/css/"},{"name":"flex","slug":"flex","permalink":"https://admin-zlj.github.io/tags/flex/"},{"name":"css3","slug":"css3","permalink":"https://admin-zlj.github.io/tags/css3/"},{"name":"blog","slug":"blog","permalink":"https://admin-zlj.github.io/tags/blog/"}]}